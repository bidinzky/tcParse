import { caller } from "@ark/fs";
import { throwInternalError } from "@ark/util";
import ts from "typescript";
import { getBenchAssertionsAtPosition } from "../cache/getCachedAssertions.js";
import { TsServer, getAbsolutePosition, getAncestors, getDescendants, nearestCallExpressionChild } from "../cache/ts.js";
import { getCallExpressionsByName, getInstantiationsContributedByNode } from "../cache/utils.js";
import { getConfig } from "../config.js";
import { compareToBaseline, queueBaselineUpdateIfNeeded } from "./baseline.js";
import { createTypeComparison } from "./measure.js";
export const createBenchTypeAssertion = (ctx) => ({
    types: (...args) => {
        ctx.lastSnapCallPosition = caller();
        instantiationDataHandler({ ...ctx, lastSnapFunctionName: "types" }, args[0]);
    }
});
export const getContributedInstantiations = (ctx) => {
    const testDeclarationAliases = getConfig().testDeclarationAliases;
    const instance = TsServer.instance;
    const file = instance.getSourceFileOrThrow(ctx.benchCallPosition.file);
    const node = nearestCallExpressionChild(file, getAbsolutePosition(file, ctx.benchCallPosition));
    const firstMatchingNamedCall = getAncestors(node).find(call => getCallExpressionsByName(call, testDeclarationAliases).length);
    if (!firstMatchingNamedCall) {
        throw new Error(`No call expressions matching the name(s) '${testDeclarationAliases.join()}' were found`);
    }
    const body = getDescendants(firstMatchingNamedCall).find(node => ts.isArrowFunction(node) || ts.isFunctionExpression(node));
    if (!body)
        throwInternalError("Unable to retrieve contents of the call expression");
    return getInstantiationsContributedByNode(file, body);
};
export const instantiationDataHandler = (ctx, args, isBenchFunction = true) => {
    const instantiationsContributed = isBenchFunction ?
        getContributedInstantiations(ctx)
        : getBenchAssertionsAtPosition(ctx.benchCallPosition)[0][1].count;
    const comparison = createTypeComparison(instantiationsContributed, args);
    compareToBaseline(comparison, ctx);
    queueBaselineUpdateIfNeeded(comparison.updated, args, ctx);
};
