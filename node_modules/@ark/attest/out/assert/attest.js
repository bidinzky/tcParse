import { caller, getCallStack } from "@ark/fs";
import { getBenchCtx } from "../bench/bench.js";
import { instantiationDataHandler } from "../bench/type.js";
import { getTypeAssertionsAtPosition } from "../cache/getCachedAssertions.js";
import { getConfig } from "../config.js";
import { assertEquals, typeEqualityMapping } from "./assertions.js";
import { ChainableAssertions } from "./chainableAssertions.js";
export const attestInternal = (value, { cfg: cfgHooks, ...ctxHooks } = {}) => {
    const position = caller();
    const cfg = { ...getConfig(), ...cfgHooks };
    const ctx = {
        versionableActual: value,
        allowRegex: false,
        originalAssertedValue: value,
        position,
        cfg,
        assertionStack: getCallStack({ offset: 1 }).join("\n"),
        ...ctxHooks
    };
    if (!cfg.skipTypes) {
        ctx.typeRelationshipAssertionEntries = getTypeAssertionsAtPosition(position);
        if (ctx.typeRelationshipAssertionEntries[0]?.[1].typeArgs[0]) {
            // if there is an expected type arg, check it immediately
            assertEquals(undefined, typeEqualityMapping, ctx);
        }
    }
    return new ChainableAssertions(ctx);
};
export const attest = Object.assign(attestInternal, {
    instantiations: (args) => {
        const attestConfig = getConfig();
        if (attestConfig.skipTypes || attestConfig.skipInlineInstantiations)
            return;
        const calledFrom = caller();
        const ctx = getBenchCtx([calledFrom.file]);
        ctx.benchCallPosition = calledFrom;
        ctx.lastSnapCallPosition = calledFrom;
        instantiationDataHandler({ ...ctx, lastSnapFunctionName: "instantiations" }, args, false);
    }
});
