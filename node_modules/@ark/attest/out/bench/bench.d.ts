import { type SourcePosition } from "@ark/fs";
import { type ParsedAttestConfig } from "../config.ts";
import { type MarkMeasure, type Measure, type TimeUnit } from "./measure.ts";
import { type BenchTypeAssertions } from "./type.ts";
export type StatName = keyof typeof stats;
export type TimeAssertionName = StatName | "mark";
type BenchFn = <fn extends BenchableFunction>(name: string, fn: fn, options?: BenchOptions) => InitialBenchAssertions<fn>;
export interface Bench extends BenchFn {
    baseline: <T>(baselineExpressions: () => T) => void;
}
export declare const bench: Bench;
export declare const stats: {
    mean: (callTimes: number[]) => number;
    median: (callTimes: number[]) => number;
};
export declare class BenchAssertions<Fn extends BenchableFunction, NextAssertions = BenchTypeAssertions, ReturnedAssertions = Fn extends () => Promise<void> ? Promise<NextAssertions> : NextAssertions> {
    private label;
    private lastCallTimes;
    private fn;
    private ctx;
    constructor(fn: Fn, ctx: BenchContext);
    private applyCallTimeHooks;
    private callTimesSync;
    private callTimesAsync;
    private createAssertion;
    private markAssertion;
    private getNextAssertions;
    private createStatMethod;
    private addUnhandledBenchException;
    median(baseline?: Measure<TimeUnit>): ReturnedAssertions;
    mean(baseline?: Measure<TimeUnit>): ReturnedAssertions;
    mark(baseline?: MarkMeasure): ReturnedAssertions;
}
export type UntilOptions = {
    ms?: number;
    count?: number;
};
export type BaseBenchOptions = {
    until?: UntilOptions;
};
export type BenchOptions = BaseBenchOptions & {
    hooks?: {
        beforeCall?: () => void;
        afterCall?: () => void;
    };
};
export type InternalBenchOptions = BenchOptions & {
    fakeCallMs?: number | "count";
};
export type BenchContext = {
    qualifiedPath: string[];
    qualifiedName: string;
    options: InternalBenchOptions;
    cfg: ParsedAttestConfig;
    assertionStack: string;
    benchCallPosition: SourcePosition;
    lastSnapCallPosition: SourcePosition | undefined;
    lastSnapFunctionName: string | undefined;
    isAsync: boolean;
};
export type BenchableFunction = () => unknown | Promise<unknown>;
export type InitialBenchAssertions<Fn extends BenchableFunction> = BenchAssertions<Fn> & BenchTypeAssertions;
export declare const getBenchCtx: (qualifiedPath: string[], isAsync?: boolean, options?: BenchOptions) => BenchContext;
export {};
