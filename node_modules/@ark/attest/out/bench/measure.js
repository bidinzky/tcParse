export const stringifyMeasure = ([value, units]) => units in timeUnitRatios ?
    stringifyTimeMeasure([value, units])
    : `${value} ${units}`;
export const TYPE_UNITS = ["instantiations"];
export const createTypeComparison = (value, baseline) => ({
    updated: [value, "instantiations"],
    baseline
});
export const timeUnitRatios = {
    ns: 0.000_001,
    us: 0.001,
    ms: 1,
    s: 1000
};
export const stringifyTimeMeasure = ([value, unit]) => `${value.toFixed(2)}${unit}`;
const convertTimeUnit = (n, from, to) => round((n * timeUnitRatios[from]) / timeUnitRatios[to], 2);
/**
 * Establish a new baseline using the most appropriate time unit
 */
export const createTimeMeasure = (ms) => {
    let bestMatch;
    for (const u in timeUnitRatios) {
        const candidateMeasure = createTimeMeasureForUnit(ms, u);
        if (!bestMatch)
            bestMatch = candidateMeasure;
        else if (bestMatch[0] >= 1) {
            if (candidateMeasure[0] >= 1 && candidateMeasure[0] < bestMatch[0])
                bestMatch = candidateMeasure;
        }
        else if (candidateMeasure[0] >= bestMatch[0])
            bestMatch = candidateMeasure;
    }
    return bestMatch;
};
const createTimeMeasureForUnit = (ms, unit) => [convertTimeUnit(ms, "ms", unit), unit];
const round = (value, decimalPlaces) => Math.round(value * 10 ** decimalPlaces) / 10 ** decimalPlaces;
export const createTimeComparison = (ms, baseline) => {
    if (baseline) {
        return {
            updated: [convertTimeUnit(ms, "ms", baseline[1]), baseline[1]],
            baseline
        };
    }
    return {
        updated: createTimeMeasure(ms),
        baseline: undefined
    };
};
