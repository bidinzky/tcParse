import { type SourcePosition } from "@ark/fs";
import type { ErrorMessage } from "@ark/util";
import type { Measure } from "../bench/measure.ts";
import { type VersionedTypeAssertion } from "../cache/getCachedAssertions.ts";
import { type AttestConfig } from "../config.ts";
import { type TypeAssertionMapping } from "./assertions.ts";
import { ChainableAssertions, type AssertionKind, type rootAssertions } from "./chainableAssertions.ts";
export type AttestFn = {
    <expected, actual extends expected = never>(...args: actual extends never ? [
        ErrorMessage<"Type-only assertion requires two explicit generic params, e.g. attest<expected, actual>">
    ] : []): void;
    <expected>(actual: expected): rootAssertions<expected, AssertionKind>;
    instantiations: (count?: Measure<"instantiations"> | undefined) => void;
};
export type VersionableActual = {} | null | undefined | TypeAssertionMapping;
export type AssertionContext = {
    versionableActual: VersionableActual;
    originalAssertedValue: unknown;
    cfg: AttestConfig;
    allowRegex: boolean;
    position: SourcePosition;
    defaultExpected?: unknown;
    assertionStack: string;
    typeRelationshipAssertionEntries?: VersionedTypeAssertion<"type">[];
    typeBenchmarkingAssertionEntries?: VersionedTypeAssertion<"bench">[];
    lastSnapName?: string;
};
export type InternalAssertionHooks = {
    [k in keyof AssertionContext]?: k extends "cfg" ? Partial<AttestConfig> : AssertionContext[k];
};
export declare const attestInternal: (value?: unknown, { cfg: cfgHooks, ...ctxHooks }?: InternalAssertionHooks) => ChainableAssertions;
export declare const attest: AttestFn;
