import { snapshot, type Constructor, type ErrorType, type isDisjoint } from "@ark/util";
import { type } from "arktype";
import type { Completions } from "../cache/writeAssertionCache.ts";
import type { AssertionContext } from "./attest.ts";
export type ChainableAssertionOptions = {
    allowRegex?: boolean;
    defaultExpected?: unknown;
};
type AssertionRecord = Record<keyof rootAssertions<any, AssertionKind>, unknown>;
export type UnwrapOptions = {
    versionable?: boolean;
    serialize?: boolean;
};
export declare class ChainableAssertions implements AssertionRecord {
    private ctx;
    constructor(ctx: AssertionContext);
    private get unversionedActual();
    private get versionableActual();
    private get serializedActual();
    unwrap(opts?: UnwrapOptions): unknown;
    private snapRequiresUpdate;
    get unknown(): this;
    is(expected: unknown): this;
    equals(expected: unknown): this;
    satisfies(def: unknown): this;
    instanceOf(expected: Constructor): this;
    get snap(): snapProperty<unknown, AssertionKind>;
    private immediateOrChained;
    get throws(): unknown;
    throwsAndHasTypeError(matchValue: string | RegExp): void;
    get completions(): any;
    get jsdoc(): any;
    get type(): any;
}
export type AssertionKind = "value" | "type";
export type rootAssertions<t, kind extends AssertionKind> = valueAssertions<t, kind> & TypeAssertionsRoot;
export type valueAssertions<t, kind extends AssertionKind> = comparableValueAssertion<t, kind> & ([t] extends [() => unknown] ? functionAssertions<kind> : {});
export type nextAssertions<kind extends AssertionKind> = "type" extends kind ? TypeAssertionsRoot : {};
export type inferredAssertions<argsType extends [value: any, ...rest: any[]], kind extends AssertionKind, chained = argsType[0]> = rootAssertions<chained, kind> & (<Args extends argsType | [] = []>(...args: Args) => nextAssertions<kind>);
export type ChainContext = {
    allowRegex?: boolean;
    defaultExpected?: unknown;
};
export type functionAssertions<kind extends AssertionKind> = {
    throws: inferredAssertions<[message: string | RegExp], kind, string>;
} & ("type" extends kind ? {
    throwsAndHasTypeError: (message: string | RegExp) => undefined;
} : {});
export type valueFromTypeAssertion<expected, chained = expected> = inferredAssertions<[expected: expected], "value", chained>;
type snapProperty<expected, kind extends AssertionKind> = {
    (expected?: snapshot<expected>): nextAssertions<kind>;
    toFile: (id: string, options?: ExternalSnapshotOptions) => nextAssertions<kind>;
    unwrap: Unwrapper<expected>;
};
export type Unwrapper<expected = unknown> = (opts?: UnwrapOptions) => expected;
export declare const nonOverlappingSatisfiesMessage = "This type has no overlap with your satisfies constraint";
export type nonOverlappingSatisfiesMessage = typeof nonOverlappingSatisfiesMessage;
type validateExpectedOverlaps<expected, satisfies> = isDisjoint<expected, satisfies> extends true ? ErrorType<nonOverlappingSatisfiesMessage> : unknown;
export type comparableValueAssertion<expected, kind extends AssertionKind> = {
    snap: snapProperty<expected, kind>;
    equals: (value: expected) => nextAssertions<kind>;
    instanceOf: (constructor: Constructor) => nextAssertions<kind>;
    is: (value: expected) => nextAssertions<kind>;
    completions: CompletionsSnap;
    jsdoc: comparableValueAssertion<string, kind>;
    satisfies: <const def>(def: type.validate<def> & validateExpectedOverlaps<expected, type.infer.In<def>>) => nextAssertions<kind>;
    unknown: Omit<comparableValueAssertion<unknown, kind>, "unknown">;
    unwrap: Unwrapper<expected>;
};
export interface CompletionsSnap {
    (value?: Completions): void;
    unwrap: Unwrapper<Completions>;
}
export type TypeAssertionsRoot = {
    type: TypeAssertionProps;
};
export type TypeAssertionProps = {
    toString: valueFromTypeAssertion<string | RegExp>;
    errors: valueFromTypeAssertion<string | RegExp, string>;
    completions: CompletionsSnap;
};
export type ExternalSnapshotOptions = {
    path?: string;
};
export {};
