import { fromCwd, readFile } from "@ark/fs";
import { printable, throwError, throwInternalError } from "@ark/util";
import * as tsvfs from "@typescript/vfs";
import { readFileSync } from "node:fs";
import { dirname, join } from "node:path";
import ts from "typescript";
import { getConfig } from "../config.js";
export class TsServer {
    rootFiles;
    virtualEnv;
    program;
    static _instance = null;
    static get instance() {
        return new TsServer();
    }
    tsConfigInfo;
    constructor(tsConfigInfo) {
        if (TsServer._instance)
            return TsServer._instance;
        this.tsConfigInfo = tsConfigInfo ?? getTsConfigInfoOrThrow();
        const tsLibPaths = getTsLibFiles(this.tsConfigInfo.parsed.options);
        // TS represents windows paths as `C:/Users/ssalb/...`
        const normalizedCwd = fromCwd().replaceAll("\\", "/");
        this.rootFiles = this.tsConfigInfo.parsed.fileNames.filter(path => {
            if (!path.startsWith(normalizedCwd))
                return;
            // exclude empty files as they lead to a crash
            // when createVirtualTypeScriptEnvironment is called
            const contents = readFile(path).trim();
            return contents !== "";
        });
        const system = tsvfs.createFSBackedSystem(tsLibPaths.defaultMapFromNodeModules, this.tsConfigInfo.path ? dirname(this.tsConfigInfo.path) : fromCwd(), ts);
        this.virtualEnv = tsvfs.createVirtualTypeScriptEnvironment(system, this.rootFiles, ts, this.tsConfigInfo.parsed.options);
        this.program = this.virtualEnv.languageService.getProgram();
        TsServer._instance = this;
    }
    getSourceFileOrThrow(path) {
        const tsPath = path.replaceAll("\\", "/");
        const existingFile = this.virtualEnv.getSourceFile(tsPath);
        if (existingFile)
            return existingFile;
        if (!this.virtualEnv.sys.fileExists(tsPath)) {
            throwInternalError(`@ark/attest: TypeScript was unable to resolve expected file at ${tsPath}.\n`);
        }
        const contents = this.virtualEnv.sys.readFile(tsPath);
        if (!contents) {
            throwInternalError(`@ark/attest: TypeScript says a file exists at ${tsPath}, but was unable to read its contents.\n`);
        }
        this.virtualEnv.createFile(tsPath, contents);
        const createdFile = this.virtualEnv.getSourceFile(tsPath);
        if (!createdFile) {
            throwInternalError(`@ark/attest: TypeScript tried to create a file at ${tsPath} but was unable to access it.`);
        }
        return createdFile;
    }
}
export const nearestCallExpressionChild = (node, position) => {
    const result = nearestBoundingCallExpression(node, position);
    if (!result) {
        throwInternalError(`Unable to find bounding call expression at position ${position} in ${node.getSourceFile().fileName}`);
    }
    return result;
};
export const nearestBoundingCallExpression = (node, position) => node.pos <= position && node.end >= position ?
    (node
        .getChildren()
        .flatMap(child => nearestBoundingCallExpression(child, position) ?? [])[0] ?? (ts.isCallExpression(node) ? node : undefined))
    : undefined;
export const getAbsolutePosition = (file, position) => {
    const pos = ts.getPositionOfLineAndCharacter(file, 
    // TS uses 0-based line and char #s
    position.line - 1, position.char - 1);
    if (!pos) {
        throwInternalError(`Absolute position ${printable(position)} does not exist in ${file.fileName}`);
    }
    return pos;
};
export const getTsConfigInfoOrThrow = () => {
    const config = getConfig();
    const tsconfig = config.tsconfig;
    let instantiatedConfig;
    let configFilePath;
    if (tsconfig !== null) {
        configFilePath =
            tsconfig ??
                ts.findConfigFile(fromCwd(), ts.sys.fileExists, "tsconfig.json");
        if (configFilePath)
            instantiatedConfig = instantiateTsconfigFromPath(configFilePath);
    }
    instantiatedConfig ??= instantiateNoFileConfig();
    return {
        path: configFilePath,
        parsed: instantiatedConfig
    };
};
const instantiateNoFileConfig = () => {
    const arkConfig = getConfig();
    const instantiatedConfig = ts.parseJsonConfigFileContent({
        compilerOptions: arkConfig.compilerOptions
    }, ts.sys, fromCwd());
    if (instantiatedConfig.errors.length > 0)
        throwConfigInstantiationError(instantiatedConfig);
    return instantiatedConfig;
};
const instantiateTsconfigFromPath = (path) => {
    const arkConfig = getConfig();
    const configFileText = readFileSync(path).toString();
    const result = ts.parseConfigFileTextToJson(path, configFileText);
    if (result.error)
        throwConfigParseError(result.error);
    const rawConfig = result.config;
    rawConfig.compilerOptions = Object.assign(rawConfig.compilerOptions ?? {}, arkConfig.compilerOptions);
    const instantiatedConfig = ts.parseJsonConfigFileContent(rawConfig, ts.sys, dirname(path), {}, path);
    if (instantiatedConfig.errors.length > 0)
        throwConfigInstantiationError(instantiatedConfig);
    return instantiatedConfig;
};
const defaultDiagnosticHost = {
    getCanonicalFileName: fileName => fileName,
    getCurrentDirectory: process.cwd,
    getNewLine: () => ts.sys.newLine
};
const throwConfigParseError = (error) => throwError(ts.formatDiagnostics([error], defaultDiagnosticHost));
const throwConfigInstantiationError = (instantiatedConfig) => throwError(ts.formatDiagnostics(instantiatedConfig.errors, defaultDiagnosticHost));
export const getTsLibFiles = (tsconfigOptions) => {
    const defaultMapFromNodeModules = tsvfs.createDefaultMapFromNodeModules(tsconfigOptions);
    const libPath = dirname(ts.getDefaultLibFilePath(tsconfigOptions));
    return {
        defaultMapFromNodeModules,
        resolvedPaths: [...defaultMapFromNodeModules.keys()].map(path => join(libPath, path))
    };
};
export const getProgram = (env) => env?.languageService.getProgram() ??
    TsServer.instance.virtualEnv.languageService.getProgram();
export const getInternalTypeChecker = (env) => getProgram(env).getTypeChecker();
export const getStringifiableType = (node) => {
    const typeChecker = getInternalTypeChecker();
    const nodeType = typeChecker.getTypeAtLocation(node);
    let stringified = typeChecker.typeToString(nodeType);
    if (stringified.includes("...")) {
        const nonTruncated = typeChecker.typeToString(nodeType, undefined, ts.TypeFormatFlags.NoTruncation);
        stringified =
            nonTruncated.includes(" any") && !stringified.includes(" any") ?
                nonTruncated.replaceAll(" any", " cyclic")
                : nonTruncated;
    }
    return Object.assign(nodeType, {
        toString: () => stringified,
        isUnresolvable: nodeType.intrinsicName === "error"
    });
};
export const extractArgumentTypesFromCall = (call) => ({
    args: call.arguments.map(arg => getStringifiableType(arg)),
    typeArgs: call.typeArguments?.map(typeArg => getStringifiableType(typeArg)) ?? []
});
export const getDescendants = (node) => getDescendantsRecurse(node);
const getDescendantsRecurse = (node) => [
    node,
    ...node.getChildren().flatMap(child => getDescendantsRecurse(child))
];
export const getAncestors = (node) => {
    const ancestors = [];
    let baseNode = node.parent;
    while (baseNode.parent !== undefined) {
        ancestors.push(baseNode);
        baseNode = baseNode.parent;
    }
    return ancestors;
};
export const getFirstAncestorByKindOrThrow = (node, kind) => getAncestors(node).find(ancestor => ancestor.kind === kind) ??
    throwInternalError(`Could not find an ancestor of kind ${ts.SyntaxKind[kind]}`);
