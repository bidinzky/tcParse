import { readJson } from "@ark/fs";
import { existsSync, readdirSync } from "node:fs";
import { join } from "node:path";
import { getConfig } from "../config.js";
import { getFileKey } from "../utils.js";
let assertionEntries;
export const getCachedAssertionEntries = () => {
    if (!assertionEntries) {
        const config = getConfig();
        if (!existsSync(config.assertionCacheDir))
            throwMissingAssertionDataError(config.assertionCacheDir);
        const assertionFiles = readdirSync(config.assertionCacheDir);
        const relationshipAssertions = {};
        const benchAssertions = {};
        assertionEntries = assertionFiles.map(file => {
            const data = readJson(join(config.assertionCacheDir, file));
            for (const fileName of Object.keys(data)) {
                const relationshipAssertionData = data[fileName].filter((entry) => "args" in entry);
                const benchAssertionData = data[fileName].filter((entry) => "count" in entry);
                relationshipAssertions[fileName] = relationshipAssertionData;
                benchAssertions[fileName] = benchAssertionData;
            }
            return [
                // remove .json extension
                file.slice(0, -5),
                relationshipAssertions,
                benchAssertions
            ];
        });
    }
    return assertionEntries;
};
const throwMissingAssertionDataError = (location) => {
    throw new Error(`Unable to find precached assertion data at '${location}'. ` +
        `Ensure the 'setup' function from @ark/attest has been called before running your tests.`);
};
const isPositionWithinRange = ({ line, char }, { start, end }) => {
    if (line < start.line || line > end.line)
        return false;
    if (line === start.line)
        return char >= start.char;
    if (line === end.line)
        return char <= end.char;
    return true;
};
const getAssertionsOfKindAtPosition = (position, kind) => {
    const fileKey = getFileKey(position.file);
    return getCachedAssertionEntries().map(([version, typeRelationshipAssertions, BenchAssertionAssertions]) => {
        const assertions = kind === "type" ? typeRelationshipAssertions : BenchAssertionAssertions;
        if (!assertions[fileKey]) {
            throw new Error(`Found no assertion data for '${fileKey}' for TypeScript version ${version}.`);
        }
        const matchingAssertion = assertions[fileKey].find(assertion => 
        /**
         * Depending on the environment, a trace can refer to any of these points
         * attest(...)
         * ^     ^   ^
         * Because of this, it's safest to check if the call came from anywhere in the expected range.
         *
         */
        isPositionWithinRange(position, assertion.location));
        if (!matchingAssertion) {
            throw new Error(`Found no assertion for TypeScript version ${version} at line ${position.line} char ${position.char} in '${fileKey}'.
	Are sourcemaps enabled and working properly?`);
        }
        return [version, matchingAssertion];
    });
};
export const getTypeAssertionsAtPosition = (position) => getAssertionsOfKindAtPosition(position, "type");
export const getBenchAssertionsAtPosition = (position) => getAssertionsOfKindAtPosition(position, "bench");
