import { caller, positionToString } from "@ark/fs";
import { printable, snapshot } from "@ark/util";
import prettier from "@prettier/sync";
import { type } from "arktype";
import * as assert from "node:assert/strict";
import { isDeepStrictEqual } from "node:util";
import { getSnapshotByName, queueSnapshotUpdate, updateExternalSnapshot } from "../cache/snapshots.js";
import { getConfig } from "../config.js";
import { chainableNoOpProxy } from "../utils.js";
import { MissingSnapshotError, TypeAssertionMapping, assertEqualOrMatching, assertEquals, assertSatisfies, callAssertedFunction, getThrownMessage, throwAssertionError } from "./assertions.js";
export class ChainableAssertions {
    ctx;
    constructor(ctx) {
        this.ctx = ctx;
    }
    get unversionedActual() {
        if (this.versionableActual instanceof TypeAssertionMapping) {
            return this.versionableActual.fn(this.ctx.typeRelationshipAssertionEntries[0][1], this.ctx).actual;
        }
        return this.versionableActual;
    }
    get versionableActual() {
        return this.ctx.versionableActual;
    }
    get serializedActual() {
        return snapshot(this.unversionedActual);
    }
    unwrap(opts) {
        const value = opts?.versionable ? this.versionableActual : this.unversionedActual;
        return opts?.serialize ? snapshot(value) : value;
    }
    snapRequiresUpdate(expectedSerialized) {
        return (!isDeepStrictEqual(this.serializedActual, expectedSerialized) ||
            // If actual is undefined, we still need to write the "undefined" literal
            // to the snap even though it will serialize to the same value as the (nonexistent) first arg
            this.unversionedActual === undefined);
    }
    get unknown() {
        return this;
    }
    is(expected) {
        assert.equal(this.unversionedActual, expected);
        return this;
    }
    equals(expected) {
        assertEquals(expected, this.versionableActual, this.ctx);
        return this;
    }
    satisfies(def) {
        assertSatisfies(type.raw(def), this.versionableActual, this.ctx);
        return this;
    }
    instanceOf(expected) {
        if (!(this.versionableActual instanceof expected)) {
            throwAssertionError({
                stack: this.ctx.assertionStack,
                message: `Expected an instance of ${expected.name} (was ${(typeof this.versionableActual === "object" &&
                    this.versionableActual !== null) ?
                    this.versionableActual.constructor.name
                    : this.serializedActual})`
            });
        }
        return this;
    }
    get snap() {
        // Use variadic args to distinguish undefined being passed explicitly from no args
        const inline = (...args) => {
            const snapName = this.ctx.lastSnapName ?? "snap";
            const expectedSerialized = snapshot(args[0]);
            if (!args.length || this.ctx.cfg.updateSnapshots) {
                const position = caller();
                if (this.ctx.cfg.failOnMissingSnapshots) {
                    throw new MissingSnapshotError(`.${snapName}() at ${positionToString(position)} must be populated.`);
                }
                if (this.snapRequiresUpdate(expectedSerialized)) {
                    const snapshotArgs = {
                        position,
                        serializedValue: this.serializedActual,
                        snapFunctionName: snapName
                    };
                    queueSnapshotUpdate(snapshotArgs);
                }
            }
            else {
                // compare as strings, but if match fails, compare again as objects
                // to give a clearer error message. This avoid problems with objects
                // like subtypes of array that do not pass node's deep equality test
                // but serialize to the same value.
                if (printable(args[0]) !== printable(this.unversionedActual))
                    assertEquals(expectedSerialized, this.serializedActual, this.ctx);
            }
            return this;
        };
        const toFile = (id, opts) => {
            const expectedSnapshot = getSnapshotByName(this.ctx.position.file, id, opts?.path);
            if (!expectedSnapshot || this.ctx.cfg.updateSnapshots) {
                if (this.snapRequiresUpdate(expectedSnapshot)) {
                    updateExternalSnapshot({
                        serializedValue: this.serializedActual,
                        position: caller(),
                        name: id,
                        customPath: opts?.path
                    });
                }
            }
            else
                assertEquals(expectedSnapshot, this.serializedActual, this.ctx);
            return this;
        };
        return Object.assign(inline, {
            toFile,
            unwrap: this.unwrap.bind(this)
        });
    }
    immediateOrChained() {
        const immediateAssertion = (...args) => {
            let expected;
            if (args.length)
                expected = args[0];
            else {
                if ("defaultExpected" in this.ctx)
                    expected = this.ctx.defaultExpected;
                else {
                    throw new Error(`Assertion call requires an arg representing the expected value.`);
                }
            }
            if (this.ctx.allowRegex)
                assertEqualOrMatching(expected, this.versionableActual, this.ctx);
            else
                assertEquals(expected, this.versionableActual, this.ctx);
            return this;
        };
        return new Proxy(immediateAssertion, {
            get: (target, prop) => this[prop]
        });
    }
    get throws() {
        const result = callAssertedFunction(this.unversionedActual);
        this.ctx.versionableActual = getThrownMessage(result, this.ctx);
        this.ctx.allowRegex = true;
        this.ctx.defaultExpected = "";
        return this.immediateOrChained();
    }
    throwsAndHasTypeError(matchValue) {
        assertEqualOrMatching(matchValue, getThrownMessage(callAssertedFunction(this.unversionedActual), this.ctx), this.ctx);
        if (!this.ctx.cfg.skipTypes) {
            assertEqualOrMatching(matchValue, new TypeAssertionMapping(data => ({
                actual: data.errors.join("\n")
            })), this.ctx);
        }
    }
    get completions() {
        if (this.ctx.cfg.skipTypes)
            return chainableNoOpProxy;
        this.ctx.versionableActual = new TypeAssertionMapping(data => {
            if (typeof data.completions === "string") {
                // if the completions were ambiguously defined, e.g. two string
                // literals with the same value, they are writen as an error
                // message to the JSON. Throw it immediately.
                throw new Error(data.completions);
            }
            return { actual: data.completions };
        });
        this.ctx.lastSnapName = "completions";
        return this.snap;
    }
    get jsdoc() {
        if (this.ctx.cfg.skipTypes)
            return chainableNoOpProxy;
        this.ctx.versionableActual = new TypeAssertionMapping(data => ({
            actual: formatTypeString(data.jsdoc ?? "")
        }));
        this.ctx.allowRegex = true;
        return this.immediateOrChained();
    }
    get type() {
        if (this.ctx.cfg.skipTypes)
            return chainableNoOpProxy;
        // We need to bind this to return an object with getters
        const self = this;
        return {
            get toString() {
                self.ctx.versionableActual = new TypeAssertionMapping(data => ({
                    actual: formatTypeString(data.args[0].type)
                }));
                self.ctx.allowRegex = true;
                return self.immediateOrChained();
            },
            get errors() {
                self.ctx.versionableActual = new TypeAssertionMapping(data => ({
                    actual: data.errors.join("\n")
                }));
                self.ctx.allowRegex = true;
                return self.immediateOrChained();
            },
            get completions() {
                return self.completions;
            }
        };
    }
}
const declarationPrefix = "type T = ";
const formatTypeString = (typeString) => prettier
    .format(`${declarationPrefix}${typeString}`, {
    semi: false,
    printWidth: 60,
    trailingComma: "none",
    parser: "typescript",
    ...getConfig().typeToStringFormat
})
    .slice(declarationPrefix.length)
    .trimEnd();
export const nonOverlappingSatisfiesMessage = "This type has no overlap with your satisfies constraint";
